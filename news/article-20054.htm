<!DOCTYPE HTML>
<html lang="zh-CN">

<head>
        <link rel="canonical" href="https://clashv2rayfree.github.io/news/article-20054.htm" />
    <title>C语言栈与队列面试题详解_C 语言</title>
        <meta name="description" content="目录  1、括号匹配问题 2、用队列实现栈 3、用栈实现队列 4、设计循环队列    1、括号匹配问题 链接直达： 有效的括号 题目：  思路： 做题前，得先明确解题方案是啥，此题用栈的思想去解决是较" />
        <link href="/assets/website/css/clashv2rayfree/bootstrap.css" rel="stylesheet" type="text/css" media="all">
    <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
    <!-- Custom Theme files -->
    <link href="/assets/website/css/clashv2rayfree/style.css" rel="stylesheet" type="text/css" media="all" />
    <!-- Custom Theme files -->
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="icon" href="/assets/website/img/clashv2rayfree/favicon.ico" type="image/x-icon"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <script type="application/x-javascript">
    addEventListener("load", function() { setTimeout(hideURLbar, 0); }, false);

    function hideURLbar() { window.scrollTo(0, 1); }
    </script>
    <!--Google Fonts-->
    <link href='http://fonts.googleapis.com/css?family=Roboto:400,500,700' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Ubuntu+Condensed' rel='stylesheet' type='text/css'>
    <!--google fonts-->
    <script src="/assets/website/js/frontend/clashv2rayfree/jquery-1.11.0.min.js"></script>
    <script src="/assets/website/js/frontend/clashv2rayfree/bootstrap.min.js"></script>
    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-0NF953KP3Y"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-0NF953KP3Y');
</script>
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3332997411212854"
     crossorigin="anonymous"></script>
</head>

<body data-page="detail">
        <!--header-top start here-->
    <div class="top-header">
    </div>
    <!--header-top end here-->
    <!--header start here-->
    <!-- NAVBAR
		================================================== -->
    <div class="header w3l">
        <div class="fixed-header">
            <div class="navbar-wrapper">
                <div class="container">
                    <nav class="navbar navbar-inverse navbar-static-top">
                        <div class="navbar-header">
                            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
                                <span class="sr-only">Toggle navigation</span>
                                <span class="icon-bar"></span>
                                <span class="icon-bar"></span>
                                <span class="icon-bar"></span>
                            </button>
                            <div class="logo">
                                                                <a class="navbar-brand" href="/">Clash V2ray Free</a>
                                                            </div>
                        </div>
                        <div id="navbar" class="navbar-collapse collapse">
                            <nav class="cl-effect-16" id="cl-effect-16">
                                <ul class="nav navbar-nav">
                                                                        <li>
                                        <a href="/">首页</a>
                                    </li>
                                                                        <li>
                                        <a href="/free-nodes/">免费节点</a>
                                    </li>
                                                                        <li>
                                        <a href="/paid-subscribe/">推荐机场</a>
                                    </li>
                                                                        <li>
                                        <a href="/news/">新闻资讯</a>
                                    </li>
                                                                        <li>
                                        <a href="#">关于</a>
                                    </li>
                                    <li>
                                        <a href="#">联系</a>
                                    </li>
                                </ul>
                            </nav>
                        </div>
                        <div class="clearfix"> </div>
                    </nav>
                </div>
                <div class="clearfix"> </div>
            </div>
        </div>
    </div>
    <!--header end here-->
    <!--about strat here-->
    <div class="about">
        <div class="container">
            <div class="about-main">
                <div class="row">
                    <div class="col-md-9">
                        <ol class="breadcrumb">
                          <li><a href="/">首页</a></li>
                          <li><a href="/news/">新闻资讯</a></li>
                          <li class="active">正文</li>
                        </ol>
                        <div class="about-top">
                            <h1>C语言栈与队列面试题详解_C 语言</h1>
                        </div>
                        <div class="about-bottom">
                                            <input type="hidden" id="share-website-info" data-name="" data-url="">
                  				  				  				<div id="navCategory"> <h5 class="catalogue">目录</h5> <ul class="first_class_ul"> <li><a href="#_label0" rel="nofollow">1、括号匹配问题</a></li> <li><a href="#_label1" rel="nofollow">2、用队列实现栈</a></li> <li><a href="#_label2" rel="nofollow">3、用栈实现队列</a></li> <li><a href="#_label3" rel="nofollow">4、设计循环队列</a></li> </ul> </div> <p class="maodian"><a name="_label0" rel="nofollow"></a></p> <h2>1、括号匹配问题</h2> <p>链接直达：</p> <p><a href="http://www.m6000.cn/wp-content/themes/begin%20lts/inc/go.php?url=https://leetcode-cn.com/problems/valid-parentheses/"   target="_blank" rel="nofollow">有效的括号</a></p> <p>题目：</p> <p style="text-align:center"><img fetchpriority="high" decoding="async" alt="" height="854" src="http://img.555519.xyz/uploads3/20220412/78a7b65489dff9e4b7b8a524c5738ca8.jpg"></p> <p>思路：</p> <p>做题前，得先明确解题方案是啥，此题用栈的思想去解决是较为方便的，栈明确指出后进先出。我们可以这样设定：</p> <ul> <li>遇到左括号“ ( ”、“ [ ”、“ { ”，入栈。</li> <li>遇到右括号“ ) ”、“ ] ”、“ } ”，出栈，跟左括号进行匹配，不匹配就报错。</li> </ul> <p>上两句话的意思就是说我去遍历字符串，如果遇到左括号，就入栈；遇到右括号，就出栈顶元素，并判断这个右括号是否与栈顶括号相匹配，若不匹配则返回false，匹配继续遍历字符串，直到遍历完全，遍历后，检查栈是否为空，若为空，则均匹配，返回true，反之false。</p> <p style="text-align:center"><img decoding="async" alt="" height="607" src="http://img.555519.xyz/uploads3/20220412/a7271482fd8e022eb0c8ed2de97ad8ff.jpg"></p> <p> 代码如下：</p> <div class="ay1code"> <pre class="brush:cpp;">//创建栈结构  typedef char STDataType;  typedef struct Stack  {  	STDataType* a; //存储数据  	int top; //栈顶的位置  	int capacity; //容量  }ST;  //初始化栈  void StackInit(ST* ps);  //销毁栈  void StackDestory(ST* ps);  //压栈  void StackPush(ST* ps, STDataType x);  //出栈  void StackPop(ST* ps);  //判空  bool StackEmpty(ST* ps);  //访问栈顶数据  STDataType StackTop(ST* ps);  //有效元素个数  int StackSize(ST* ps);     //定义：  //初始化栈  void StackInit(ST* ps)  {  	assert(ps);  	ps-&gt;a = NULL;  	ps-&gt;top = 0;  	ps-&gt;capacity = 0;  }  //销毁栈  void StackDestory(ST* ps)  {  	assert(ps);  	free(ps-&gt;a);  	ps-&gt;a = NULL;  	ps-&gt;capacity = ps-&gt;top = 0;  }  //压栈  void StackPush(ST* ps, STDataType x)  {  	assert(ps);  	//如果栈满了，考虑扩容  	if (ps-&gt;top == ps-&gt;capacity)  	{  		int newcapacity = ps-&gt;capacity == 0 ? 4 : ps-&gt;capacity * 2; //检测容量  		ps-&gt;a = (STDataType*)realloc(ps-&gt;a, newcapacity * sizeof(STDataType));  		if (ps-&gt;a == NULL)  		{  			printf("realloc fail\n");  			exit(-1);  		}  		ps-&gt;capacity = newcapacity; //更新容量  	}  	ps-&gt;a[ps-&gt;top] = x;//将数据压进去  	ps-&gt;top++;//栈顶上移  }  //出栈  void StackPop(ST* ps)  {  	assert(ps);  	assert(ps-&gt;top &gt; 0);  	ps-&gt;top--;  }  //判空  bool StackEmpty(ST* ps)  {  	assert(ps);  	return ps-&gt;top == 0; //如果top为0，那么就为真，即返回  }  //访问栈顶数据  STDataType StackTop(ST* ps)  {  	assert(ps);  	assert(ps-&gt;top &gt; 0);  	return ps-&gt;a[ps-&gt;top - 1]; //top-1的位置才为栈顶的元素  }  //有效元素个数  int StackSize(ST* ps)  {  	assert(ps);  	return ps-&gt;top;  }     //创建好了栈开始实现  bool isValid(char* s) {      ST st;//先创建一个栈      StackInit(&amp;st);//初始化栈      while (*s)      {          if (*s == '[' || *s == '(' || *s == '{')          {              StackPush(&amp;st, *s); //如果是左括号就入栈              ++s;          }          else          {              if (StackEmpty(&amp;st))              {                  return false; //此处说明前面根本没有左括号，导致栈为空，直接返回false              }              char top = StackTop(&amp;st); //获取栈顶元素              StackPop(&amp;st); //出栈顶元素，接下来进行匹配              if ((*s == ']' &amp;&amp; top != '[')                  || (*s == ')' &amp;&amp; top != '(')                  || (*s == '}' &amp;&amp; top != '{'))              {                  StackDestory(&amp;st); //返回前先销毁，防止内存泄漏                  return false; //如果不匹配，直接返回false              }              else              {                  //此时匹配，继续比较，直到遍历结束                  ++s;              }          }      }      //栈为空，说明所有左括号都匹配      bool ret = StackEmpty(&amp;st);      StackDestory(&amp;st); //返回前先销毁，防止内存泄漏      return ret;  }</pre> </div> <p class="maodian"><a name="_label1" rel="nofollow"></a></p> <h2>2、用队列实现栈</h2> <p>链接直达：</p> <p><a href="http://www.m6000.cn/wp-content/themes/begin%20lts/inc/go.php?url=https://leetcode-cn.com/problems/implement-stack-using-queues/"   target="_blank" rel="nofollow">用队列实现栈</a></p> <p>题目：</p> <p style="text-align:center"><img decoding="async" alt="" height="1200" src="http://img.555519.xyz/uploads3/20220412/41fb2289e8b5c609a4063586da6f2efe.jpg"></p> <p> 思路：</p> <p>做题之前，再明确下两个基本知识点</p> <ul> <li>栈：后进先出</li> <li>队列：先进先出</li> </ul> <p>此题要用先进先出的队列来实现后进先出的栈，并模拟实现队列的基本接口。</p> <p>假设我们有一串数字，进入队列A顺序为1 2 3 4，此时再有一个队列B，此时我们取队列A的队头数据，并将其导入队列B，当队列A出到只剩最后一个时，把队列A给pop删掉，此时队列B就是1 2 3，间接性是实现了栈的功能，实现了后进先出的功能。当我们需要再入数据时，只需往不为空的队列入即可。再出就像刚刚那样。简而言之两句话：</p> <ul> <li>入栈：push数据到不为空的队列。</li> <li>出栈：把不为空的队列的数据前N-1导入另一个空队列，最后剩下一个删掉。</li> </ul> <p>本质：保持一个队列存储数据，另外一个队列空着，要出栈时，空队列用来导数据。</p> <p style="text-align:center"><img loading="lazy" decoding="async" alt="" height="270" src="http://img.555519.xyz/uploads3/20220412/8aa1cc22ddd82101b07541e694a36197.jpg"></p> <p> 代码如下：</p> <div class="ay1code"> <pre class="brush:cpp;">//创建队列结构  typedef int QDataType; //方便后续更改存储数据类型，本文以int为例   //创建队列节点  typedef struct QueueNode  {  	QDataType data; //存储数据  	struct QueueNode* next; //记录下一个节点  }QNode;  //保存队头和队尾  typedef struct Queue  {  	QNode* head; //头指针  	QNode* tail; //尾指针  }Queue;  //初始化队列  void QueueInit(Queue* pq);  //销毁队列  void QueueDestory(Queue* pq);  //入队列  void QueuePush(Queue* pq, QDataType x);  //出队列  void QueuePop(Queue* pq);  //判空  bool QueueEmpty(Queue* pq);  //获取有效元素个数  size_t QueueSize(Queue* pq);  //获取队头元素  QDataType QueueFront(Queue* pq);  //获取队尾元素  QDataType QueueBack(Queue* pq);     //定义：  //初始化队列  void QueueInit(Queue* pq)  {  	assert(pq);  	pq-&gt;head = pq-&gt;tail = NULL;  }  //销毁队列  void QueueDestory(Queue* pq)  {  	assert(pq);  	QNode* cur = pq-&gt;head;  	while (cur)  	{  		QNode* next = cur-&gt;next;  		free(cur);  		cur = next;  	}  	pq-&gt;head = pq-&gt;tail = NULL;  }  //入队列  void QueuePush(Queue* pq, QDataType x)  {  	assert(pq);  	//创建一个新节点保存数据  	QNode* newnode = (QNode*)malloc(sizeof(QNode));  	//暴力检测newnode，因为malloc的都要检测  	assert(newnode);  	newnode-&gt;next = NULL;  	newnode-&gt;data = x;  	//如果一开始没有数据，为空的情况  	if (pq-&gt;tail == NULL)  	{  		assert(pq-&gt;head == NULL);  		pq-&gt;head = pq-&gt;tail = newnode;  	}  	else  	{  		pq-&gt;tail-&gt;next = newnode;  		pq-&gt;tail = newnode;  	}  }  //出队列  void QueuePop(Queue* pq)  {  	assert(pq);  	assert(pq-&gt;head &amp;&amp; pq-&gt;tail); //tail和head均不能为空  	//特殊：当删到head=tail的位置时  	if (pq-&gt;head-&gt;next == NULL)  	{  		free(pq-&gt;head);  		pq-&gt;head = pq-&gt;tail = NULL;  	}  	//一般情况  	else  	{  		//保存head的下一个节点  		QNode* next = pq-&gt;head-&gt;next;  		free(pq-&gt;head);  		pq-&gt;head = next;  	}  }  //判空  bool QueueEmpty(Queue* pq)  {  	assert(pq);  	return pq-&gt;head == NULL;  }  //获取有效元素个数  size_t QueueSize(Queue* pq)  {  	assert(pq);  	QNode* cur = pq-&gt;head;  	size_t size = 0;  	while (cur)  	{  		size++;  		cur = cur-&gt;next;  	}  	return size;  }  //获取队头元素  QDataType QueueFront(Queue* pq)  {  	assert(pq);  	assert(pq-&gt;head); //头部不能为空  	return pq-&gt;head-&gt;data;  }  //获取队尾元素  QDataType QueueBack(Queue* pq)  {  	assert(pq);  	assert(pq-&gt;tail); //尾部不能为空  	return pq-&gt;tail-&gt;data;  }     /**************创建好队列结构，开始正文模拟实现栈**************/  typedef struct {  	Queue q1; //队列q1  	Queue q2; //队列q2  } MyStack;        MyStack* myStackCreate() {  	MyStack* pst = (MyStack*)malloc(sizeof(MyStack)); //申请一个MyStack类型的栈  	assert(pst);  	QueueInit(&amp;pst-&gt;q1);//初始化队列1  	QueueInit(&amp;pst-&gt;q2);//初始化队列2  	return pst;  }     void myStackPush(MyStack* obj, int x) {  	assert(obj);  	if (!QueueEmpty(&amp;obj-&gt;q1))  	{  		QueuePush(&amp;obj-&gt;q1, x);//如果q1不为空，就往q1插入数据  	}  	else  	{  		QueuePush(&amp;obj-&gt;q2, x);//这儿不需要知道q2是否为空，直接push  	}  }     int myStackPop(MyStack* obj) {  	assert(obj);  	Queue* emptyQ = &amp;obj-&gt;q1; //默认q1为空  	Queue* nonEmtpyQ = &amp;obj-&gt;q2;//默认q2不为空  	if (!QueueEmpty(&amp;obj-&gt;q1))  	{  		emptyQ = &amp;obj-&gt;q2; //若假设错误，则q2为空  		nonEmtpyQ = &amp;obj-&gt;q1;//此时q1就为空  	}  	while (QueueSize(nonEmtpyQ) &gt; 1)  	{  		QueuePush(emptyQ, QueueFront(nonEmtpyQ)); //把非空的队列数据导到空的队列，直到只剩一个  		QueuePop(nonEmtpyQ); //此时把非空的队头数据给删掉，方便后续导入数据  	}  	int top = QueueFront(nonEmtpyQ); //记录此时的栈顶数据  	QueuePop(nonEmtpyQ); //删除栈顶数据，使该队列置空  	return top;  }     int myStackTop(MyStack* obj) {  	assert(obj);  	if (!QueueEmpty(&amp;obj-&gt;q1))  	{  		return QueueBack(&amp;obj-&gt;q1);//如果q1不为空，返回  	}  	else  	{  		return QueueBack(&amp;obj-&gt;q2);  	}  }     bool myStackEmpty(MyStack* obj) {  	assert(obj);  	//两个队列均为空，则为空  	return QueueEmpty(&amp;obj-&gt;q1) &amp;&amp; QueueEmpty(&amp;obj-&gt;q2);  }     void myStackFree(MyStack* obj) {  	assert(obj);  	QueueDestory(&amp;obj-&gt;q1); //释放q1  	QueueDestory(&amp;obj-&gt;q2); //释放q2  	free(obj);  }</pre> </div> <p class="maodian"><a name="_label2" rel="nofollow"></a></p> <h2>3、用栈实现队列</h2> <p>链接直达：</p> <p><a href="http://www.m6000.cn/wp-content/themes/begin%20lts/inc/go.php?url=https://leetcode-cn.com/problems/implement-queue-using-stacks/"   target="_blank" rel="nofollow">用栈实现队列</a></p> <p>题目：</p> <p style="text-align:center"><img loading="lazy" decoding="async" alt="" height="865" src="http://img.555519.xyz/uploads3/20220412/68bf21320e14143a0a1a1b7609388031.jpg"></p> <p> 思路：</p> <p>假设入栈的顺序为1 2 3 4，那么根据题意，想要达到1 2 3 4的出栈顺序以此实现队列。</p> <p>此题和上一道题正好相反，用栈实现队列，上一道题中，我们需要把数据来回导，从而实现栈的后进先出功能，但是此题就完全不需要来回导了，只需要导一次即可。</p> <p>假设我们有两个栈，分别命名为pushST和popST。并往栈pushST里头入4个数据1 2 3 4，在出数据时根据栈的性质只能拿到4，此时我们直接把4拿下来并导入栈popST里头，并继续把pushST栈里的数据导下来，直至栈pushST数据为空。此时popST数据即为  4 3 2 1，刚好反过来了。</p> <p>根据队列的先进先出规则，进1 2 3 4，出必然是1 2 3 4，而上文已经知晓栈popST的数据为4 3 2 1，当删除数据时，会按照1 2 3 4 的顺序逐个删除。恰好利用栈的性质实现了队列的先进先出功能。并只需导一次即可，无需多次。</p> <p style="text-align:center"><img loading="lazy" decoding="async" alt="" height="350" src="http://img.555519.xyz/uploads3/20220412/83d4a2a79add936a94829518d099a60d.jpg"></p> <p> 代码如下：</p> <div class="ay1code"> <pre class="brush:cpp;">//创建栈结构  typedef int STDataType;  typedef struct Stack  {      STDataType* a; //存储数据      int top; //栈顶的位置      int capacity; //容量  }ST;  //初始化栈  void StackInit(ST* ps);  //销毁栈  void StackDestory(ST* ps);  //压栈  void StackPush(ST* ps, STDataType x);  //出栈  void StackPop(ST* ps);  //判空  bool StackEmpty(ST* ps);  //访问栈顶数据  STDataType StackTop(ST* ps);  //有效元素个数  int StackSize(ST* ps);     //初始化栈  void StackInit(ST* ps)  {      assert(ps);      ps-&gt;a = NULL;      ps-&gt;top = 0;      ps-&gt;capacity = 0;  }  //销毁栈  void StackDestory(ST* ps)  {      assert(ps);      free(ps-&gt;a);      ps-&gt;a = NULL;      ps-&gt;capacity = ps-&gt;top = 0;  }  //压栈  void StackPush(ST* ps, STDataType x)  {      assert(ps);      //如果栈满了，考虑扩容      if (ps-&gt;top == ps-&gt;capacity)      {          int newcapacity = ps-&gt;capacity == 0 ? 4 : ps-&gt;capacity; //检测容量          ps-&gt;a = (STDataType*)realloc(ps-&gt;a, newcapacity * sizeof(STDataType));          if (ps-&gt;a == NULL)          {              printf("realloc fail\n");              exit(-1);          }          ps-&gt;capacity = newcapacity; //更新容量      }      ps-&gt;a[ps-&gt;top] = x;//将数据压进去      ps-&gt;top++;//栈顶上移  }  //出栈  void StackPop(ST* ps)  {      assert(ps);      assert(ps-&gt;top &gt; 0);      ps-&gt;top--;  }  //判空  bool StackEmpty(ST* ps)  {      assert(ps);      return ps-&gt;top == 0; //如果top为0，那么就为真，即返回  }  //访问栈顶数据  STDataType StackTop(ST* ps)  {      assert(ps);      assert(ps-&gt;top &gt; 0);      return ps-&gt;a[ps-&gt;top - 1]; //top-1的位置才为栈顶的元素  }  //有效元素个数  int StackSize(ST* ps)  {      assert(ps);      return ps-&gt;top;  }     /************创建好栈结构，开始正文************/  typedef struct {      ST pushST; //插入数据的栈      ST popST; //删除数据的栈  } MyQueue;        MyQueue* myQueueCreate() {      MyQueue* obj = (MyQueue*)malloc(sizeof(MyQueue)); //申请队列类型      assert(obj);      StackInit(&amp;obj-&gt;pushST);//初始化pushST      StackInit(&amp;obj-&gt;popST);//初始化popST      return obj;  }     void myQueuePush(MyQueue* obj, int x) {      assert(obj);      StackPush(&amp;obj-&gt;pushST, x);//不管有没有数据，都插入  }     int myQueuePop(MyQueue* obj) {      assert(obj);      if (StackEmpty(&amp;obj-&gt;popST)) //如果popST数据为空，要从pushST里导入数据才能删除      {          while (!StackEmpty(&amp;obj-&gt;pushST)) //pushST数据不为空，就一直向popST里导入数据          {              StackPush(&amp;obj-&gt;popST, StackTop(&amp;obj-&gt;pushST));//把pushST栈顶数据导到popST里              StackPop(&amp;obj-&gt;pushST);//导完后把pushST栈顶元素删掉，方便后续继续导          }      }      int front = StackTop(&amp;obj-&gt;popST); //记录popST栈顶元素      StackPop(&amp;obj-&gt;popST);//删除popST栈顶元素，实现队列先进先出      return front; //返回栈顶数据  }     //取队头数据  int myQueuePeek(MyQueue* obj) {      assert(obj);      //如果popST数据为空，要从pushST里导入数据才能取到队头数据      if (StackEmpty(&amp;obj-&gt;popST))      {          while (!StackEmpty(&amp;obj-&gt;pushST)) //pushST数据不为空，就一直向popST里导入数据          {              StackPush(&amp;obj-&gt;popST, StackTop(&amp;obj-&gt;pushST));//把pushST栈顶数据导到popST里              StackPop(&amp;obj-&gt;pushST);//导完后把pushST栈顶元素删掉，方便后续继续导          }      }      return StackTop(&amp;obj-&gt;popST);//直接返回栈顶元素  }     bool myQueueEmpty(MyQueue* obj) {      return StackEmpty(&amp;obj-&gt;pushST) &amp;&amp; StackEmpty(&amp;obj-&gt;popST);  }     void myQueueFree(MyQueue* obj) {      assert(obj);      StackDestory(&amp;obj-&gt;pushST);      StackDestory(&amp;obj-&gt;popST);      free(obj);  }</pre> </div> <p class="maodian"><a name="_label3" rel="nofollow"></a></p> <h2>4、设计循环队列</h2> <p>链接直达：</p> <p><a href="http://www.m6000.cn/wp-content/themes/begin%20lts/inc/go.php?url=https://leetcode-cn.com/problems/design-circular-queue/"   target="_blank" rel="nofollow">设计循环队列</a></p> <p>题目：</p> <p style="text-align:center"><img loading="lazy" decoding="async" alt="" height="899" src="http://img.555519.xyz/uploads3/20220412/bed0e9e814fad026d1c5075c1290019e.jpg"></p> <p> 思路：</p> <p>此题可以用数组实现，也可以用链表实现，但其实是用数组更加方便些。</p> <p>数组：</p> <p>假设队头front和队尾tail都指向第一个数据，在队尾插入数据，tail随着数据的插入跟着移动，tail始终为最后一个数据的下一个位置。删除数据只需要将队头front往后挪即可，不需要按照之前队列的pop一样删完还挪动数据，因为是循环链表，且数据是可以重复利用的。</p> <p style="text-align:center"><img loading="lazy" decoding="async" alt="" height="381" src="http://img.555519.xyz/uploads3/20220412/bd3693897944ddfab691e811627c01ce.jpg"></p> <p>这样分析下来再加上画图看似没有什么缺陷，但是存在两个问题？</p> <ul> <li>什么情况下数组为空？</li> <li>什么情况下数组满了？</li> </ul> <p>问题1：</p> <p>当tail = front时数组为空，看似没什么问题，但相等又要分两种情况。先画个图：</p> <p style="text-align:center"><img loading="lazy" decoding="async" alt="" height="152" src="http://img.555519.xyz/uploads3/20220412/335ad877a83f2c2d7d48fb8ee1e3d49e.jpg"></p> <p>由上图得知，在情况一下，数组里确实是一个数据也没有，并且tail也是等于front的，满足数组为空的条件，但是在情况二下，数组的数据全满，此时的tail和front同样是相等的，这里数组不为空了，而是全满，由此可见，是存在问题的。</p> <p>解决方案：</p> <p>这里我们可以多开一个空间，不存放数据，只是用来分别数组为空或满。原理如下：当数组长度为4时，也就是说实际能存放3个有效数据，另外一个空间用来判断空或满，此时判断空或满的条件如下：</p> <ul> <li>front == tail 时是空</li> <li>tail 下一个位置是 front 时，就是满</li> </ul> <p style="text-align:center"><img loading="lazy" decoding="async" alt="" height="610" src="http://img.555519.xyz/uploads3/20220412/d5ca88284a0ae0ec86e7d6c682f53067.jpg"></p> <p> 代码如下：</p> <div class="ay1code"> <pre class="brush:cpp;">typedef struct {      int* a; //用数组模拟环形队列      int front;//队头      int tail; //队尾      int k; //表示存的数据长度为k  } MyCircularQueue;     bool myCircularQueueIsFull(MyCircularQueue* obj); //前置声明  bool myCircularQueueIsEmpty(MyCircularQueue* obj);//前置声明     MyCircularQueue* myCircularQueueCreate(int k) {      MyCircularQueue* obj = (MyCircularQueue*)malloc(sizeof(MyCircularQueue));//创建环形链表结构      assert(obj);      obj-&gt;a = (int*)malloc(sizeof(int) * (k + 1));//多开一个空间，便于后续区分空或满      obj-&gt;front = obj-&gt;tail = 0;      obj-&gt;k = k; //队列存储有效数据长度为k      return obj;  }     bool myCircularQueueEnQueue(MyCircularQueue* obj, int value) {      if (myCircularQueueIsFull(obj))      {          return false; //队列已满，不能插入数据      }      obj-&gt;a[obj-&gt;tail] = value; //赋值      if (obj-&gt;tail == obj-&gt;k)      {          obj-&gt;tail = 0; //当tail走到尾端      }      else      {          obj-&gt;tail++;      }      return true;  }     bool myCircularQueueDeQueue(MyCircularQueue* obj) {      if (myCircularQueueIsEmpty(obj))      {          return false; //队列为空，不能删除      }      if (obj-&gt;front == obj-&gt;k)      {          obj-&gt;front = 0; //当front走到尾端      }      else      {          obj-&gt;front++;      }      return true;  }  //取头  int myCircularQueueFront(MyCircularQueue* obj) {      if (myCircularQueueIsEmpty(obj))      {          return -1; //队列为空，取不了      }      return obj-&gt;a[obj-&gt;front]; //返回队头  }  //取尾  int myCircularQueueRear(MyCircularQueue* obj) {      if (myCircularQueueIsEmpty(obj))      {          return -1; //队列为空，取不了      }      if (obj-&gt;tail == 0)      {          return obj-&gt;a[obj-&gt;k]; //tail为0，队尾在长度的最后一个位置      }      else      {          return obj-&gt;a[obj-&gt;tail - 1];      }  }     bool myCircularQueueIsEmpty(MyCircularQueue* obj) {      return obj-&gt;front == obj-&gt;tail; //front==tail时为空  }     bool myCircularQueueIsFull(MyCircularQueue* obj) {      if (obj-&gt;tail == obj-&gt;k &amp;&amp; obj-&gt;front == 0)      {          return true; //当tail尾端，front在头端时也是满      }      else      {          return obj-&gt;tail + 1 == obj-&gt;front; //一般情况，当tail的下一个位置为front时为满      }  }     void myCircularQueueFree(MyCircularQueue* obj) {      free(obj-&gt;a);      free(obj);  }</pre> </div> 			                <div class="clearfix"></div>
                <div class="col-md-12 mt-5">
                                        <p>上一个：<a href="/news/article-19599.htm">全国宠物粮食基地排名第一（中国宠物粮之乡）</a></p>
                                        <p>下一个：<a href="/news/article-20055.htm">宠物医院美团好评文案 宠物医院美团好评文案大全</a></p>
                                    </div>
                                        </div>

                        
                    </div>
                    <div class="col-md-3">
                        <div class="panel panel-default">
    <div class="panel-heading">
        <h3 class="panel-title">热门文章</h3>
    </div>
    <div class="panel-body">
        <ul class="p-0 x-0" style="list-style: none;margin: 0;padding: 0;">
                        <li class="py-2"><a href="/free-nodes/2024-4-23-free-ssr-node.htm" title="「4月23日」最高速度22.5M/S，2024年Shadowrocket/Clash/SSR/V2ray每天更新免费节点订阅链接">「4月23日」最高速度22.5M/S，2024年Shadowrocket/Clash/SSR/V2ray每天更新免费节点订阅链接</a></li>
                        <li class="py-2"><a href="/news/article-29291.htm" title="兰州宠物用品批发市场电话地址（兰州宠物用品批发市场电话地址）">兰州宠物用品批发市场电话地址（兰州宠物用品批发市场电话地址）</a></li>
                        <li class="py-2"><a href="/free-nodes/2024-12-13-free-v2ray-subscribe.htm" title="「12月13日」最高速度18.5M/S，2024年Clash/Shadowrocket/V2ray/SSR每天更新免费订阅源地址">「12月13日」最高速度18.5M/S，2024年Clash/Shadowrocket/V2ray/SSR每天更新免费订阅源地址</a></li>
                        <li class="py-2"><a href="/free-nodes/2024-5-22-node-share.htm" title="「5月22日」最高速度20.6M/S，2024年Shadowrocket/SSR/V2ray/Clash每天更新免费节点订阅链接">「5月22日」最高速度20.6M/S，2024年Shadowrocket/SSR/V2ray/Clash每天更新免费节点订阅链接</a></li>
                        <li class="py-2"><a href="/news/article-34069.htm" title="K8S 将 pod 调度到指定 nodes 上运行">K8S 将 pod 调度到指定 nodes 上运行</a></li>
                        <li class="py-2"><a href="/free-nodes/2024-6-3-free-ssr-subscribe.htm" title="「6月3日」最高速度20.6M/S，2024年Clash/V2ray/Shadowrocket/SSR每天更新免费节点订阅链接">「6月3日」最高速度20.6M/S，2024年Clash/V2ray/Shadowrocket/SSR每天更新免费节点订阅链接</a></li>
                        <li class="py-2"><a href="/free-nodes/2024-9-28-free-node-subscribe.htm" title="「9月28日」最高速度19.6M/S，2024年V2ray/SSR/Clash/Shadowrocket每天更新免费节点订阅链接">「9月28日」最高速度19.6M/S，2024年V2ray/SSR/Clash/Shadowrocket每天更新免费节点订阅链接</a></li>
                        <li class="py-2"><a href="/free-nodes/2024-6-6-free-node-subscribe-links.htm" title="「6月6日」最高速度23M/S，2024年Clash/Shadowrocket/V2ray/SSR每天更新免费节点订阅链接">「6月6日」最高速度23M/S，2024年Clash/Shadowrocket/V2ray/SSR每天更新免费节点订阅链接</a></li>
                        <li class="py-2"><a href="/free-nodes/2024-4-29-shadowrocket-node.htm" title="「4月29日」最高速度20.5M/S，2024年SSR/Shadowrocket/V2ray/Clash每天更新免费节点订阅链接">「4月29日」最高速度20.5M/S，2024年SSR/Shadowrocket/V2ray/Clash每天更新免费节点订阅链接</a></li>
                        <li class="py-2"><a href="/free-nodes/2024-6-10-clash-v2ray-ss-ssr.htm" title="「6月10日」最高速度22.1M/S，2024年Shadowrocket/V2ray/Clash/SSR每天更新免费节点订阅链接">「6月10日」最高速度22.1M/S，2024年Shadowrocket/V2ray/Clash/SSR每天更新免费节点订阅链接</a></li>
                    </ul>
    </div>
</div>

<div class="panel panel-default">
    <div class="panel-heading">
        <h3 class="panel-title">归纳</h3>
    </div>
    <div class="panel-body">
        <ul class="p-0 x-0" style="list-style: none;margin: 0;padding: 0;">
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">3</span> <a href="/date/2025-01/" title="2025-01 归档">2025-01</a></h4>
            </li>
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">93</span> <a href="/date/2024-12/" title="2024-12 归档">2024-12</a></h4>
            </li>
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">33</span> <a href="/date/2024-11/" title="2024-11 归档">2024-11</a></h4>
            </li>
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">31</span> <a href="/date/2024-10/" title="2024-10 归档">2024-10</a></h4>
            </li>
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">30</span> <a href="/date/2024-09/" title="2024-09 归档">2024-09</a></h4>
            </li>
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">31</span> <a href="/date/2024-08/" title="2024-08 归档">2024-08</a></h4>
            </li>
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">27</span> <a href="/date/2024-07/" title="2024-07 归档">2024-07</a></h4>
            </li>
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">29</span> <a href="/date/2024-06/" title="2024-06 归档">2024-06</a></h4>
            </li>
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">31</span> <a href="/date/2024-05/" title="2024-05 归档">2024-05</a></h4>
            </li>
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">26</span> <a href="/date/2024-04/" title="2024-04 归档">2024-04</a></h4>
            </li>
                    </ul>
    </div>
</div>


                    </div>
                </div>
            </div>
        </div>
    </div>
    <!--about end here-->
        <!--copy rights start here-->
    <div class="copy-rights">
        <div class="container">
            <div class="copy-rights-main">
                            <p>
                                <a href="/">首页</a> | 
                                <a href="/free-node/">免费节点</a> | 
                                <a href="/news/">新闻资讯</a> |
                                <a href="/about-us.htm">关于我们</a> |
                                <a href="/disclaimer.htm">免责申明</a> |
                                <a href="/privacy.htm">隐私申明</a> |
                                <a href="/sitemap.xml">网站地图</a>
                            </p>
                <p>
                    ClashV2rayFree官网节点站 版权所有
                    <br />
                    Powered by WordPress
                </p>
            </div>
        </div>
    </div>
    <script src="https://www.freeclashnode.com/assets/js/frontend/invite-url.js"></script><script src="/assets/website/js/frontend/G.js"></script>
</body>

</html>