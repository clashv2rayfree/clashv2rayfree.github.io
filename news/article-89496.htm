<!DOCTYPE HTML>
<html xml:lang="zh-CN" lang="zh-CN">

<head>
        <link rel="canonical" href="https://clashv2rayfree.github.io/news/article-89496.htm" />
    <title>ASP.NET Core WebApi返回结果统一包装实践</title>
        <meta name="description" content="前言 &nbsp;&nbsp;&nbsp;&nbsp;近期在重新搭建一套基于ASP.NET Core WebAPI的框架，这其中确实带来了不少的收获，毕竟当你想搭建一套框架的时候，你总会不自觉的去想，" />
    
    <meta name="author" content="ClashV2rayFree官网节点站">
    <meta property="og:type" content="article" />
    <meta property="og:url" content="https://clashv2rayfree.github.io/news/article-89496.htm" />
    <meta property="og:site_name" content="ClashV2rayFree官网节点站" />
    <meta property="og:title" content="ASP.NET Core WebApi返回结果统一包装实践" />
    <meta property="og:image" content="https://clashv2rayfree.github.io/uploads/20240412/76bfbe6a54d5e145a928fab8090131f1.webp" />
        <meta property="og:release_date" content="2025-04-06T10:06:08" />
    <meta property="og:updated_time" content="2025-04-06T10:06:08" />
        <meta property="og:description" content="前言 &nbsp;&nbsp;&nbsp;&nbsp;近期在重新搭建一套基于ASP.NET Core WebAPI的框架，这其中确实带来了不少的收获，毕竟当你想搭建一套框架的时候，你总会不自觉的去想，" />
        
    <link href="/assets/website/css/clashv2rayfree/bootstrap.css" rel="stylesheet" type="text/css" media="all">
    <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
    <!-- Custom Theme files -->
    <link href="/assets/website/css/clashv2rayfree/style.css" rel="stylesheet" type="text/css" media="all" />
    <!-- Custom Theme files -->
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="icon" href="/assets/website/img/clashv2rayfree/favicon.ico" type="image/x-icon"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <script type="application/x-javascript">
    addEventListener("load", function() { setTimeout(hideURLbar, 0); }, false);

    function hideURLbar() { window.scrollTo(0, 1); }
    </script>
    <!--Google Fonts-->
    <link href='http://fonts.googleapis.com/css?family=Roboto:400,500,700' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Ubuntu+Condensed' rel='stylesheet' type='text/css'>
    <!--google fonts-->
    <script src="/assets/website/js/frontend/clashv2rayfree/jquery-1.11.0.min.js"></script>
    <script src="/assets/website/js/frontend/clashv2rayfree/bootstrap.min.js"></script>

    <meta name="applicable-device" content="pc,mobile" />
    <meta name="renderer" content="webkit" />
    <meta name="force-rendering" content="webkit" />
    <meta http-equiv="Cache-Control" content="no-transform" />
    <meta name="robots" content="max-image-preview:large" />
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="apple-mobile-web-app-title" content="ASP.NET Core WebApi返回结果统一包装实践">
    <meta name="format-detection" content="telephone=no">

    <link rel="dns-prefetch" href="https:/www.googletagmanager.com">
    <link rel="dns-prefetch" href="https://www.googleadservices.com">
    <link rel="dns-prefetch" href="https://www.google-analytics.com">
    <link rel="dns-prefetch" href="https://pagead2.googlesyndication.com">
    <link rel="dns-prefetch" href="https://cm.g.doubleclick.net">
    <link rel="dns-prefetch" href="https://fonts.googleapis.com">
    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-0NF953KP3Y"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-0NF953KP3Y');
</script>
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3332997411212854"
     crossorigin="anonymous"></script>
</head>

<body data-page="detail">
        <!--header-top start here-->
    <div class="top-header">
    </div>
    <!--header-top end here-->
    <!--header start here-->
    <!-- NAVBAR
		================================================== -->
    <div class="header w3l">
        <div class="fixed-header">
            <div class="navbar-wrapper">
                <div class="container">
                    <nav class="navbar navbar-inverse navbar-static-top">
                        <div class="navbar-header">
                            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
                                <span class="sr-only">Toggle navigation</span>
                                <span class="icon-bar"></span>
                                <span class="icon-bar"></span>
                                <span class="icon-bar"></span>
                            </button>
                            <div class="logo">
                                                                <a class="navbar-brand" href="/">Clash V2ray Free</a>
                                                            </div>
                        </div>
                        <div id="navbar" class="navbar-collapse collapse">
                            <nav class="cl-effect-16" id="cl-effect-16">
                                <ul class="nav navbar-nav">
                                                                        <li>
                                        <a href="/">首页</a>
                                    </li>
                                                                        <li>
                                        <a href="/free-nodes/">免费节点</a>
                                    </li>
                                                                        <li>
                                        <a href="/paid-subscribe/">推荐机场</a>
                                    </li>
                                                                        <li>
                                        <a href="/client.htm">客户端</a>
                                    </li>
                                                                        <li>
                                        <a href="/news/">新闻资讯</a>
                                    </li>
                                                                    </ul>
                            </nav>
                        </div>
                        <div class="clearfix"> </div>
                    </nav>
                </div>
                <div class="clearfix"> </div>
            </div>
        </div>
    </div>
    <!--header end here-->
    <!--about strat here-->
    <div class="about">
        <div class="container">
            <div class="about-main">
                <div class="row">
                    <div class="col-md-9">
                        <ol class="breadcrumb">
                          <li><a href="/">首页</a></li>
                          <li><a href="/news/">新闻资讯</a></li>
                          <li class="active">正文</li>
                        </ol>
                        <div class="about-top">
                            <h1>ASP.NET Core WebApi返回结果统一包装实践</h1>
                        </div>
                        <div class="about-bottom">
                                            <input type="hidden" id="share-website-info" data-name="" data-url="">
                  				  				  				<h3 id="前言">前言</h3> <p>&nbsp;&nbsp;&nbsp;&nbsp;近期在重新搭建一套基于ASP.NET Core WebAPI的框架，这其中确实带来了不少的收获，毕竟当你想搭建一套框架的时候，你总会不自觉的去想，如何让这套框架变得更完善一点更好用一点。其中在关于WebApi统一结果返回的时候，让我也有了更一步的思考，首先是如何能更好的限制返回统一的格式，其次是关于结果的包装一定是更简单更强大。在不断的思考和完善中，终于有了初步的成果，便分享出来，学无止境思考便无止境，希望以此能与君共勉。</p> <h3 id="统一结果类封装">统一结果类封装</h3> <p>&nbsp;&nbsp;&nbsp;&nbsp;首先如果让返回的结果格式统一，就得有一个统一的包装类去包装所有的返回结果，因为返回的具体数据虽然格式一致，但是具体的值的类型是不确定的，因此我们这里需要定义个泛型类。当然如果你不选择泛型类的话用dynamic或者object类型也是可以的,但是这样的话可能会带来两点不足</p> <ul> <li>一是可能会存在装箱拆箱的操作。</li> <li>二是如果引入swagger的话是没办法生成返回的类型的，因为dynamic或object类型都是执行具体的action时才能确定返回类型的，但是swagger的结构是首次运行的时候就获取到的，因此无法感知具体类型。</li> </ul> <h4 id="定义包装类">定义包装类</h4> <p>上面我们也说了关于定义泛型类的优势，这里就话不多说来直接封装一个结果返回的包装类</p> <pre><code class="language-csharp">public class ResponseResult&lt;T&gt; {     /// &lt;summary&gt;     /// 状态结果     /// &lt;/summary&gt;     public ResultStatus Status { get; set; } = ResultStatus.Success;      private string? _msg;      /// &lt;summary&gt;     /// 消息描述     /// &lt;/summary&gt;     public string? Message     {         get         {             // 如果没有自定义的结果描述，则可以获取当前状态的描述             return !string.IsNullOrEmpty(_msg) ? _msg : EnumHelper.GetDescription(Status);         }         set         {             _msg = value;         }     }      /// &lt;summary&gt;     /// 返回结果     /// &lt;/summary&gt;     public T Data { get; set; } }</code></pre> <p>其中这里的<code>ResultStatus</code>是一个枚举类型，用于定义具体的返回状态码，用于判断返回的结果是正常还是异常或者其他，我这里只是简单的定义了一个最简单的示例，有需要的话也可以自行扩展</p> <pre><code class="language-csharp">public enum ResultStatus {     [Description("请求成功")]     Success = 1,     [Description("请求失败")]     Fail = 0,     [Description("请求异常")]     Error = -1 }</code></pre> <p>这种情况下定义枚举类型并且结合它的<code>DescriptionAttribute</code>的特性去描述枚举的含义是一个不错的选择，首先它可以统一管理每个状态的含义，其次是更方便的获取每个状态对应的描述。这样的话如果没有自定义的结果描述，则可以获取当前状态的描述来充当默认值的情况。这个时候在写具体action的时候会是以下的效果</p> <pre><code class="language-csharp">[HttpGet("GetWeatherForecast")] public ResponseResult&lt;IEnumerable&lt;WeatherForecast&gt;&gt; GetAll() {     var datas = Enumerable.Range(1, 5).Select(index =&gt; new WeatherForecast     {         Date = DateTime.Now.AddDays(index),         TemperatureC = Random.Shared.Next(-20, 55),         Summary = Summaries[Random.Shared.Next(Summaries.Length)]     });     return new ResponseResult&lt;IEnumerable&lt;WeatherForecast&gt;&gt; {  Data = datas }; }</code></pre> <p>这样的话每次编写action的时候都可以返回一个<code>ResponseResult&lt;T&gt;</code>的结果了，这里就体现出了使用枚举定义状态码的优势了，相当一部分场景我们可以省略了状态码甚至是消息的编写，毕竟很多时候在保障功能的情况下，代码还是越简介越好的，更何况是一些高频操作呢。</p> <h4 id="升级一下操作">升级一下操作</h4> <p>上面虽然我们定义了<code>ResponseResult&lt;T&gt;</code>来统一包装返回结果，但是每次还得new一下，在无疑是不太方便的，而且还要每次都还得给属性赋值啥的，也是够麻烦的，这个时候就想，如果能有相关的辅助方法去简化操作就好了，方法不用太多能满足场景就好，也就是够用就好，最主要的是能支持扩展就可以。因此，进一步升级一下结果包装类，来简化一下操作</p> <pre><code class="language-csharp">public class ResponseResult&lt;T&gt; {     /// &lt;summary&gt;     /// 状态结果     /// &lt;/summary&gt;     public ResultStatus Status { get; set; } = ResultStatus.Success;      private string? _msg;      /// &lt;summary&gt;     /// 消息描述     /// &lt;/summary&gt;     public string? Message     {         get         {             return !string.IsNullOrEmpty(_msg) ? _msg : EnumHelper.GetDescription(Status);         }         set         {             _msg = value;         }     }      /// &lt;summary&gt;     /// 返回结果     /// &lt;/summary&gt;     public T Data { get; set; }      /// &lt;summary&gt;     /// 成功状态返回结果     /// &lt;/summary&gt;     /// &lt;param name="result"&gt;返回的数据&lt;/param&gt;     /// &lt;returns&gt;&lt;/returns&gt;     public static ResponseResult&lt;T&gt; SuccessResult(T data)     {         return new ResponseResult&lt;T&gt; { Status = ResultStatus.Success, Data = data };     }      /// &lt;summary&gt;     /// 失败状态返回结果     /// &lt;/summary&gt;     /// &lt;param name="code"&gt;状态码&lt;/param&gt;     /// &lt;param name="msg"&gt;失败信息&lt;/param&gt;     /// &lt;returns&gt;&lt;/returns&gt;     public static ResponseResult&lt;T&gt; FailResult(string? msg = null)     {         return new ResponseResult&lt;T&gt; { Status = ResultStatus.Fail, Message = msg };     }      /// &lt;summary&gt;     /// 异常状态返回结果     /// &lt;/summary&gt;     /// &lt;param name="code"&gt;状态码&lt;/param&gt;     /// &lt;param name="msg"&gt;异常信息&lt;/param&gt;     /// &lt;returns&gt;&lt;/returns&gt;     public static ResponseResult&lt;T&gt; ErrorResult(string? msg = null)     {         return new ResponseResult&lt;T&gt; { Status = ResultStatus.Error, Message = msg };     }      /// &lt;summary&gt;     /// 自定义状态返回结果     /// &lt;/summary&gt;     /// &lt;param name="status"&gt;&lt;/param&gt;     /// &lt;param name="result"&gt;&lt;/param&gt;     /// &lt;returns&gt;&lt;/returns&gt;     public static ResponseResult&lt;T&gt; Result(ResultStatus status, T data, string? msg = null)     {         return new ResponseResult&lt;T&gt; { Status = status, Data = data, Message = msg };     } }</code></pre> <p>这里进一步封装了几个方法，至于具体封装几个这种方法，还是那句话够用就好，这里我封装了几个常用的操作，成功状态、失败状态、异常状态、最完全状态，这几种状态基本上可以满足大多数的场景，不够的话可以自行进行进一步的多封装几个方法。这样的话在action使用的时候就会简化很多,省去了手动属性赋值</p> <pre><code class="language-csharp">[HttpGet("GetWeatherForecast")] public ResponseResult&lt;IEnumerable&lt;WeatherForecast&gt;&gt; GetAll() {     var datas = Enumerable.Range(1, 5).Select(index =&gt; new WeatherForecast     {         Date = DateTime.Now.AddDays(index),         TemperatureC = Random.Shared.Next(-20, 55),         Summary = Summaries[Random.Shared.Next(Summaries.Length)]     });     return ResponseResult&lt;IEnumerable&lt;WeatherForecast&gt;&gt;.SuccessResult(datas); }</code></pre> <h4 id="进一步完善">进一步完善</h4> <p>上面我们通过完善<code>ResponseResult&lt;T&gt;</code>类的封装，确实在某些程度上节省了一部分操作，但是还是有点美中不足，那就是每次返回结果的时候，虽然定义了几个常用的静态方法去操作返回结果，但是每次还得通过手动去把<code>ResponseResult&lt;T&gt;</code>类给请出来才能使用，现在呢想在操作返回结果的时候不想看到它了。这个呢也很简单，我们可以借助微软针对MVC的Controller的封装进一步得到一个思路，那就是定义一个基类的Controller，我们在Controller基类中，把常用的返回结果封装一些方法，这样在Controller的子类中呢就可以直接调用这些方法，而不需要关注如何去编写方法的返回类型了，话不多说动手把Controller基类封装起来</p> <pre><code class="language-csharp">[ApiController] [Route("api/[controller]")] public class ApiControllerBase : ControllerBase {     /// &lt;summary&gt;     /// 成功状态返回结果     /// &lt;/summary&gt;     /// &lt;param name="result"&gt;返回的数据&lt;/param&gt;     /// &lt;returns&gt;&lt;/returns&gt;     protected ResponseResult&lt;T&gt; SuccessResult&lt;T&gt;(T result)     {         return ResponseResult&lt;T&gt;.SuccessResult(result);     }      /// &lt;summary&gt;     /// 失败状态返回结果     /// &lt;/summary&gt;     /// &lt;param name="code"&gt;状态码&lt;/param&gt;     /// &lt;param name="msg"&gt;失败信息&lt;/param&gt;     /// &lt;returns&gt;&lt;/returns&gt;     protected ResponseResult&lt;T&gt; FailResult&lt;T&gt;(string? msg = null)     {         return ResponseResult&lt;T&gt;.FailResult(msg);     }      /// &lt;summary&gt;     /// 异常状态返回结果     /// &lt;/summary&gt;     /// &lt;param name="code"&gt;状态码&lt;/param&gt;     /// &lt;param name="msg"&gt;异常信息&lt;/param&gt;     /// &lt;returns&gt;&lt;/returns&gt;     protected ResponseResult&lt;T&gt; ErrorResult&lt;T&gt;(string? msg = null)     {         return ResponseResult&lt;T&gt;.ErrorResult(msg);     }      /// &lt;summary&gt;     /// 自定义状态返回结果     /// &lt;/summary&gt;     /// &lt;param name="status"&gt;&lt;/param&gt;     /// &lt;param name="result"&gt;&lt;/param&gt;     /// &lt;returns&gt;&lt;/returns&gt;     protected ResponseResult&lt;T&gt; Result&lt;T&gt;(ResultStatus status, T result, string? msg = null)     {         return ResponseResult&lt;T&gt;.Result(status, result, msg);     } }</code></pre> <p>有了这么一个大神的辅助，一切似乎又向着美好进发了一步，这样的话每次我们自定义的Controller可以继承<code>ApiControllerBase</code>类，从而使用里面的简化操作。所以再写起来代码，大概是这么一个效果</p> <pre><code class="language-csharp">public class WeatherForecastController : ApiControllerBase {     private static readonly string[] Summaries = new[]     {        "Freezing", "Bracing", "Chilly", "Cool", "Mild", "Warm", "Balmy", "Hot", "Sweltering", "Scorching"     };      [HttpGet("GetWeatherForecast")]     public ResponseResult&lt;IEnumerable&lt;WeatherForecast&gt;&gt; GetAll()     {         var datas = Enumerable.Range(1, 5).Select(index =&gt; new WeatherForecast         {             Date = DateTime.Now.AddDays(index),             TemperatureC = Random.Shared.Next(-20, 55),             Summary = Summaries[Random.Shared.Next(Summaries.Length)]         });         return SuccessResult(datas);     } }</code></pre> <p>这个时候确实变得很美好了，但是还是没有逃脱一点，那就是我还是得通过特定的方法来得到一个<code>ResponseResult&lt;T&gt;</code>类型的返回结果，包括我们给<code>ResponseResult&lt;T&gt;</code>类封装静态方法，或者甚至是定义<code>ApiControllerBase</code>基类，都是为了进一步简化这个操作。现在呢我想告别这个限制，我能不能把返回的结果直接就默认的转化成<code>ResponseResult&lt;T&gt;</code>类型的结果呢？当然可以，这也是通过ASP.NET Core的封装思路中得到的启发，借助<code>implicit</code>自动完成隐式转换，这个在ASP.NET Core的<code>ActionResult&lt;T&gt;</code>类中也有体现</p> <pre><code class="language-csharp">public static implicit operator ActionResult&lt;TValue&gt;(TValue value) {     return new ActionResult&lt;TValue&gt;(value); }</code></pre> <p>通过这个思路我们可以进一步完善<code>ResponseResult&lt;T&gt;</code>类的实现方式，给它添加一个隐式转换的操作，仅仅定义一个方法即可，在<code>ResponseResult&lt;T&gt;</code>类中继续完善</p> <pre><code class="language-csharp">/// &lt;summary&gt; /// 隐式将T转化为ResponseResult&lt;T&gt; /// &lt;/summary&gt; /// &lt;param name="value"&gt;&lt;/param&gt; public static implicit operator ResponseResult&lt;T&gt;(T value) {     return new ResponseResult&lt;T&gt; { Data = value }; }</code></pre> <p>这种对于绝大部分返回成功结果的时候提供了非常简化的操作，这个时候如果你再去使用action的时候就可以进一步来简化返回值的操作了</p> <pre><code class="language-csharp">[HttpGet("GetWeatherForecast")] public ResponseResult&lt;IEnumerable&lt;WeatherForecast&gt;&gt; GetAll() {     var datas = Enumerable.Range(1, 5).Select(index =&gt; new WeatherForecast     {         Date = DateTime.Now.AddDays(index),         TemperatureC = Random.Shared.Next(-20, 55),         Summary = Summaries[Random.Shared.Next(Summaries.Length)]     });     return datas.ToList(); }</code></pre> <p>因为我们定义了<code>T</code>到<code>ResponseResult&lt;T&gt;</code>的隐式转换，所以这个时候我们就可以直接返回结果了，而不需要手动对结果返回值进行包装。</p> <h3 id="漏网之鱼处理">漏网之鱼处理</h3> <p>在上面我们为了尽量简化action返回<code>ResponseResult&lt;T&gt;</code>的统一返回结构的封装，已经对<code>ResponseResult&lt;T&gt;</code>类进行了许多的封装，并且还通过封装<code>ApiControllerBase</code>基类进一步简化这一操作，但是终究还是避免不了一点，那就是很多时候可能想不起来对action的返回值去加<code>ResponseResult&lt;T&gt;</code>类型的返回值，但是我们之前的所有封装都得建立在必须要声明<code>ResponseResult&lt;T&gt;</code>类型的返回值的基础上才行，否则就不存在统一返回格式这一说法了。所以针对这些漏网之鱼，我们必须要有统一的拦截机制，这样才能更完整的针对返回结果进行处理，针对这种对action返回值的操作，我们首先想到的就是定义<code>过滤器</code>进行处理，因此笔者针对这一现象封装了一个统一包装结果的过滤器，实现如下</p> <pre><code class="language-csharp">public class ResultWrapperFilter : ActionFilterAttribute {     public override void OnResultExecuting(ResultExecutingContext context)     {         var controllerActionDescriptor = context.ActionDescriptor as ControllerActionDescriptor;         var actionWrapper = controllerActionDescriptor?.MethodInfo.GetCustomAttributes(typeof(NoWrapperAttribute), false).FirstOrDefault();         var controllerWrapper = controllerActionDescriptor?.ControllerTypeInfo.GetCustomAttributes(typeof(NoWrapperAttribute), false).FirstOrDefault();         //如果包含NoWrapperAttribute则说明不需要对返回结果进行包装，直接返回原始值         if (actionWrapper != null || controllerWrapper != null)         {             return;         }          //根据实际需求进行具体实现         var rspResult = new ResponseResult&lt;object&gt;();         if (context.Result is ObjectResult)         {             var objectResult = context.Result as ObjectResult;             if (objectResult?.Value == null)             {                 rspResult.Status = ResultStatus.Fail;                 rspResult.Message = "未找到资源";                 context.Result = new ObjectResult(rspResult);             }             else             {                 //如果返回结果已经是ResponseResult&lt;T&gt;类型的则不需要进行再次包装了                 if (objectResult.DeclaredType.IsGenericType &amp;&amp; objectResult.DeclaredType?.GetGenericTypeDefinition() == typeof(ResponseResult&lt;&gt;))                 {                     return;                 }                 rspResult.Data = objectResult.Value;                 context.Result = new ObjectResult(rspResult);             }             return;         }     } }</code></pre> <p>在使用WebAPI的过程中，我们的action绝大部分是直接返回<code>ViewModel</code>或<code>Dto</code>而并没有返回<code>ActionResult</code>类型相关，但是无妨，这个时候MVC的底层操作会为我们将这些自定义的类型包装成<code>ObjectResult</code>类型的，因此我们的<code>ResultWrapperFilter</code>过滤器也是通过这一机制进行操作的。这里有两点需要考虑的</p> <ul> <li>首先是，我们必须要允许并非所有的返回结果都要进行<code>ResponseResult&lt;T&gt;</code>的包装，为了满足这一需求我们还定义了<code>NoWrapperAttribute</code>来实现这一效果，只要Controller或Action有<code>NoWrapperAttribute</code>的修饰则不对返回结果进行任何处理。</li> <li>其次是，如果我们的Action上的返回类型已经是<code>ResponseResult&lt;T&gt;</code>类型的，则也不需要对返回结果进行再次的包装。</li> </ul> <p>关于<code>ResultWrapperFilter</code>的定义其实很简单，因为在这里它只是起到了一个标记的作用</p> <pre><code class="language-csharp">[AttributeUsage(AttributeTargets.Class | AttributeTargets.Method, AllowMultiple = false, Inherited = false)] public class NoWrapperAttribute:Attribute { }</code></pre> <p>到了这里，还有一种特殊的情况需要注意，那就是当程序发生异常的时候，我们上面的这些机制也是没有办法生效的，因此我们还需要定义一个针对全局异常处理的拦截机制，同样是可以使用统一异常处理过滤器进行操作，实现如下</p> <pre><code class="language-csharp">public class GlobalExceptionFilter : IExceptionFilter {     private readonly ILogger&lt;GlobalExceptionFilter&gt; _logger;     public GlobalExceptionFilter(ILogger&lt;GlobalExceptionFilter&gt; logger)     {         _logger = logger;     }      public void OnException(ExceptionContext context)     {         //异常返回结果包装         var rspResult = ResponseResult&lt;object&gt;.ErrorResult(context.Exception.Message);         //日志记录         _logger.LogError(context.Exception, context.Exception.Message);         context.ExceptionHandled = true;         context.Result = new InternalServerErrorObjectResult(rspResult);     }      public class InternalServerErrorObjectResult : ObjectResult     {         public InternalServerErrorObjectResult(object value) : base(value)         {             StatusCode = StatusCodes.Status500InternalServerError;         }     } }</code></pre> <p>写完过滤器了，千万不能忘了全局注册一下，否则它也就只能看看了，不会起到任何效果</p> <pre><code class="language-csharp">builder.Services.AddControllers(options =&gt; {     options.Filters.Add&lt;ResultWrapperFilter&gt;();     options.Filters.Add&lt;GlobalExceptionFilter&gt;(); });</code></pre> <h3 id="漏网之鱼另一种处理">漏网之鱼另一种处理</h3> <p>当然针对上面两种针对漏网之鱼的处理，在ASP.NET Core上还可以通过中间件的方式进行处理，至于过滤器和中间件有何不同，相信大家已经非常清楚了，核心不同总结起来就一句话<code>二者的处理阶段不同，即针对管道的生命周期处理是不一样的，中间件可以处理任何生命周期在它之后的场景，但是过滤器只管理Controller这一块的一亩三分地</code>但是针对结果包装这一场景，笔者觉得使用过滤器的方式更容易处理一点，因为毕竟我们是要操作Action的返回结果，通过过滤器中我们可以直接拿到返回结果的值。但是这个操作如果在中间件里进行操作的话，只能通过读取<code>Response.Body</code>进行操作了，笔者这里也封装了一个操作，如下所示</p> <pre><code class="language-csharp">public static IApplicationBuilder UseResultWrapper(this IApplicationBuilder app) {         var serializerOptions = app.ApplicationServices.GetRequiredService&lt;IOptions&lt;JsonOptions&gt;&gt;().Value.JsonSerializerOptions;         serializerOptions.Encoder = JavaScriptEncoder.UnsafeRelaxedJsonEscaping;         return app.Use(async (context, next) =&gt;         {             var originalResponseBody = context.Response.Body;             try             {                 //因为Response.Body没办法进行直接读取，所以需要特殊操作一下                 using var swapStream = new MemoryStream();                 context.Response.Body = swapStream;                 await next();                 //判断是否出现了异常状态码，需要特殊处理                 if (context.Response.StatusCode == StatusCodes.Status500InternalServerError)                 {                     context.Response.Body.Seek(0, SeekOrigin.Begin);                     await swapStream.CopyToAsync(originalResponseBody);                     return;                 }                 var endpoint = context.Features.Get&lt;IEndpointFeature&gt;()?.Endpoint;                 if (endpoint != null)                 {                     //只针对application/json结果进行处理                     if (context.Response.ContentType.ToLower().Contains("application/json"))                     {                         //判断终结点是否包含NoWrapperAttribute                         NoWrapperAttribute noWrapper = endpoint.Metadata.GetMetadata&lt;NoWrapperAttribute&gt;();                         if (noWrapper != null)                         {                             context.Response.Body.Seek(0, SeekOrigin.Begin);                             await swapStream.CopyToAsync(originalResponseBody);                             return;                         }                         //获取Action的返回类型                         var controllerActionDescriptor = context.GetEndpoint()?.Metadata.GetMetadata&lt;ControllerActionDescriptor&gt;();                         if (controllerActionDescriptor != null)                         {                             //泛型的特殊处理                             var returnType = controllerActionDescriptor.MethodInfo.ReturnType;                             if (returnType.IsGenericType &amp;&amp; (returnType.GetGenericTypeDefinition() == typeof(Task&lt;&gt;) || returnType.GetGenericTypeDefinition() == typeof(ValueTask&lt;&gt;)))                             {                                 returnType = returnType.GetGenericArguments()[0];                             }                             //如果终结点已经是ResponseResult&lt;T&gt;则不进行包装处理                             if (returnType.IsGenericType &amp;&amp; returnType.GetGenericTypeDefinition() == typeof(ResponseResult&lt;&gt;))                             {                                 context.Response.Body.Seek(0, SeekOrigin.Begin);                                 await swapStream.CopyToAsync(originalResponseBody);                                 return;                             }                             context.Response.Body.Seek(0, SeekOrigin.Begin);                             //反序列化得到原始结果                             var result = await JsonSerializer.DeserializeAsync(context.Response.Body, returnType, serializerOptions);                             //对原始结果进行包装                             var bytes = JsonSerializer.SerializeToUtf8Bytes(ResponseResult&lt;object&gt;.SuccessResult(result), serializerOptions);                             new MemoryStream(bytes).CopyTo(originalResponseBody);                             return;                         }                     }                 }                 context.Response.Body.Seek(0, SeekOrigin.Begin);                 await swapStream.CopyToAsync(originalResponseBody);             }             finally             {                 //将原始的Body归还回来                 context.Response.Body = originalResponseBody;             }         });     } }</code></pre> <p>相信通过上面的处理，我们就可以更容易的看出来，谁更容易的对统一结果进行包装处理了，毕竟我们是针对Action的返回结果进行处理，而过滤器显然就是为针对Controller和Action的处理而生的。但是通过中间件的方式能更完整的针对结果进行处理，因为许多时候我们可能是在自定义的中间件里直接拦截请求并返回，但是根据二八原则这种情况相对于Action的返回值毕竟是少数，有这种情况我们可以通过直接<code>ResponseResult&lt;T&gt;</code>封装的方法进行返回操作，也很方便。但是这个时候呢，关于异常处理我们通过全局异常处理中间件，则能更多的处理更多的场景，且没有副作用，看一下它的定义</p> <pre><code class="language-csharp">public static IApplicationBuilder UseException(this IApplicationBuilder app) {     return app.UseExceptionHandler(configure =&gt;     {         configure.Run(async context =&gt;         {             var exceptionHandlerPathFeature = context.Features.Get&lt;IExceptionHandlerPathFeature&gt;();             var ex = exceptionHandlerPathFeature?.Error;             if (ex != null)             {                 var _logger = context.RequestServices.GetService&lt;ILogger&lt;IExceptionHandlerPathFeature&gt;&gt;();                 var rspResult = ResponseResult&lt;object&gt;.ErrorResult(ex.Message);                 _logger?.LogError(ex, message: ex.Message);                 context.Response.StatusCode = StatusCodes.Status500InternalServerError;                 context.Response.ContentType = "application/json;charset=utf-8";                 await context.Response.WriteAsync(rspResult.SerializeObject());             }         });     }); }</code></pre> <p>使用全局异常梳理中间件是没有副作用的，主要因为在异常处理的时候我们不需要读取<code>Response.Body</code>进行读取操作的，所以至于是选择异常处理中间件还是过滤器，大家可以针对自己的实际场景进行选择，两种方式都是可以的。</p> <h3 id="总结">总结</h3> <p>&nbsp;&nbsp;&nbsp;&nbsp;本文主要是展示了针对ASP.NET Core WeApi结果统一返回格式的相关操作，通过示例我们一步一步的展示了完成这一目标的不断升级的实现，虽然整体看起来比较简单，但是却承载着笔者一次又一次的思考升级。每次实现完一个阶段，都会去想有没有更好的方式去完善它。这其中还有一些思路来自微软源码为我们提供的思路，所以很多时候还是建议大家去看一看源码的，可以在很多时候为我们提供一种解决问题的思路。正如我看到的一句话，读源码也是一种围城，外面的人不想进去，里面的人不想出来。如果大家有更好的实现方式，欢迎一起讨论。曾经的时候我会为自己学到了一个新的技能而感到高兴，到了后来我会对有一个好的思路，或者好的解决问题的方法而感到高兴。读万卷书很重要，行万里路同样重要，读书是沉淀，行路是实践，结合到一起才能更好的促进，而不是只选择一种。</p> 			                <div class="clearfix"></div>
                <div class="col-md-12 mt-5">
                                        <p>上一个：<a href="/news/article-88757.htm">国内动物疫苗上市公司 国内动物疫苗上市公司有哪些</a></p>
                                        <p>下一个：<a href="/news/article-89497.htm">济南免费领养宠物狗在哪里（济南免费领养宠物狗在哪里办理）</a></p>
                                    </div>
                                        </div>

                        
                    </div>
                    <div class="col-md-3">
                        <div class="panel panel-default">
    <div class="panel-heading">
        <h3 class="panel-title">热门文章</h3>
    </div>
    <div class="panel-body">
        <ul class="p-0 x-0" style="list-style: none;margin: 0;padding: 0;">
                        <li class="py-2"><a href="/news/article-77477.htm" title="我们如何使用MySQL函数STR_TO_DATE（Column，&#8217;％input_format&#8217;）？">我们如何使用MySQL函数STR_TO_DATE（Column，&#8217;％input_format&#8217;）？</a></li>
                        <li class="py-2"><a href="/free-nodes/2025-3-30-free-node-subscribe-links.htm" title="「3月30日」最高速度19.6M/S，2025年Shadowrocket/V2ray/SSR/Clash每天更新免费订阅源地址">「3月30日」最高速度19.6M/S，2025年Shadowrocket/V2ray/SSR/Clash每天更新免费订阅源地址</a></li>
                        <li class="py-2"><a href="/free-nodes/2025-4-7-free-high-speed-nodes.htm" title="「4月7日」最高速度18.8M/S，2025年V2ray/Clash/SSR/Shadowrocket每天更新免费订阅源地址">「4月7日」最高速度18.8M/S，2025年V2ray/Clash/SSR/Shadowrocket每天更新免费订阅源地址</a></li>
                        <li class="py-2"><a href="/free-nodes/2025-3-19-shadowrocket-node.htm" title="「3月19日」最高速度19.5M/S，2025年SSR/V2ray/Shadowrocket/Clash每天更新免费订阅源地址">「3月19日」最高速度19.5M/S，2025年SSR/V2ray/Shadowrocket/Clash每天更新免费订阅源地址</a></li>
                        <li class="py-2"><a href="/news/article-66912.htm" title="WPF路由事件">WPF路由事件</a></li>
                        <li class="py-2"><a href="/news/article-83022.htm" title="宠物美容店要什么许可证（宠物美容店应该在哪经营）">宠物美容店要什么许可证（宠物美容店应该在哪经营）</a></li>
                        <li class="py-2"><a href="/news/article-80213.htm" title="开宠物店靠什么赚钱（开宠物店挣钱么）">开宠物店靠什么赚钱（开宠物店挣钱么）</a></li>
                        <li class="py-2"><a href="/news/article-85877.htm" title="检查pytorch是否安装成功、查看torch和cuda的版本">检查pytorch是否安装成功、查看torch和cuda的版本</a></li>
                        <li class="py-2"><a href="/news/article-72103.htm" title="哈尔滨王春生***2（哈尔滨市王春生判决书）">哈尔滨王春生***2（哈尔滨市王春生判决书）</a></li>
                        <li class="py-2"><a href="/free-nodes/2025-3-12-free-ssr-subscribe.htm" title="「3月12日」最高速度20.3M/S，2025年Clash/V2ray/Shadowrocket/SSR每天更新免费订阅源地址">「3月12日」最高速度20.3M/S，2025年Clash/V2ray/Shadowrocket/SSR每天更新免费订阅源地址</a></li>
                    </ul>
    </div>
</div>

<div class="panel panel-default">
    <div class="panel-heading">
        <h3 class="panel-title">归纳</h3>
    </div>
    <div class="panel-body">
        <ul class="p-0 x-0" style="list-style: none;margin: 0;padding: 0;">
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">24</span> <a href="/date/2025-04/" title="2025-04 归档">2025-04</a></h4>
            </li>
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">90</span> <a href="/date/2025-03/" title="2025-03 归档">2025-03</a></h4>
            </li>
                    </ul>
    </div>
</div>


                    </div>
                </div>
            </div>
        </div>
    </div>
    <!--about end here-->
        <!--copy rights start here-->
    <div class="copy-rights">
        <div class="container">
            <div class="copy-rights-main">
                                    <p>
                                                <a href="/">首页</a> |
                                                <a href="/free-nodes/">免费节点</a> |
                                                <a href="/paid-subscribe/">推荐机场</a> |
                                                <a href="/client.htm">客户端</a> |
                                                <a href="/news/">新闻资讯</a> |
                                                <a href="/about-us.htm">关于我们</a> |
                        <a href="/disclaimer.htm">免责申明</a> |
                        <a href="/privacy.htm">隐私申明</a> |
                        <a href="/sitemap.xml">网站地图</a>
                    </p>
                <p>
                    ClashV2rayFree官网节点站 版权所有
                    <br />
                    Powered by WordPress
                </p>
            </div>
        </div>
    </div>
    <script src="https://www.freeclashnode.com/assets/js/frontend/invite-url.js"></script><script src="/assets/website/js/frontend/G.js"></script>
</body>

</html>